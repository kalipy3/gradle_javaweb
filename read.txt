read.txt

:Author: kalipy
:Email: kalipy@debian
:Date: 2020-09-17 23:07

BookStore项目

1.需求分析，建立模型
    建立登录注册相关模型(Bean层)
        建立用户表
            当数据库表很多时候，也要分层，一般按照命名规则分层即可
                create database bookstore_01

                create table bs_user(
                    id int(12) primary key auto_increment,
                    username varchar(100) not null unique,
                    password varchar(100) not null,
                    email varchar(100)
                )

        建立对应的User类

    建立Dao层：操作数据库
        JDBCUtils:用来获取数据库连接,使用c3p0获取连接
            导包 mysql-connector.jar c3p0.jar commons-dbutils.jar

        建立BaseDao,专门用来被其他的dao继承，BaseDao定义了一些基本的操作
            BaseDao<T>:
                public T getBean()
                public List<T> getBeanList()
                public int update()

        USerDao:操作User表的Dao类
            面向接口编程
                定义一个UserDao接口 定义UserDao有什么方法
                    UserDao接口：
                        User getUserByUserNameAndPassWord(User user);
                        boolean registUser(User user);

    建立Service层
        UserService:完成登录注册功能
        面向接口编程
            UserService接口：
                User login(User user);
                boolean regist(User users);


    建立Servlet层：处理用户请求
        LoginServlet:处理登录请求
        RegistServlet:处理注册请求

    界面
        修改响应逻辑
       

--------------------------------------------------------------------------

第三阶段 项目优化
2.登录注册，如果发生错误应该有错误提示信息
    错误提示：
        1.用户输入用户名密码
        2.发送登录请求
        3.登录servlet来处理登录请求-->查用户
            成功：重定向到页面
            失败：转发到登录页面
        4.又会在浏览器上显示登录页面。想要在登录页面动态获取错误信息，在转发之前，设置一个错误消息提示，把它放在域中。jsp就可以在域中取数据

3.表单回显
    当登录或注册失败时，回到登录或注册页面我们希望将之前填写的信息保留(表单回显)

4.优化servlet的逻辑
    一个请求对应了一个Servlet
        UserService-->login(),regist(),xx()和用户相关的业务逻辑都放在了UserService.
     问题：
        可不可以和用户相关的请求(登录，注册..等)放在一个Servlet里

        和用户相关的请求    UserServlet
        和图书相关的请求    BookServlet
        ...

     分析：
        注册，登录 都被UserServlet-->所以注册登录都请求同一个地址
        可以为请求添加一个method字段，提交的时候,带上method值
        if(method.eqauls("regist"))调用注册方法
        if(method.eqauls("login"))调用登录方法

     问题：
        上面看起来好像没什么问题了，但是，get请求时，表单的数据会被带上，而之前请求地址中的数据会被表单数据覆盖掉,请运行代码测试

        解决：
            添加一个隐藏的表单项
            <input type="hidden" name="method" value="login">
            <input type="hidden" name="method" value="regist">

     为了不陷入层层的if判断，我们改用反射也来实现一下

     所有的Servlet都是通过反射来调用相应的方法，所以我们可以抽取一个BaseServlet
        
        用户发送请求
        method=regist/login ----------->    BaseServlet
                                            doGet()
           UserServlet    <-----------------doPost()
           regist()
           login()
              |
              |
             \|/
             完成响应


5.我们使用分层结构
    Servlet-->Service-->Dao-->bean:在系统中数据都使用对象包装
    注册：第一步：来到注册Servlet,获取数据封装对象
    登录：第一步：来到登录Servlet,获取数据封装对象

    xxx:第一步：来到xxServlet，获取数据封装对象

    我们应该将获取数据，封装对象这个过程抽取出来
    因为封装对象，还牵扯到数据转型，很麻烦..
        User user = Utils.param2Bean(t);
    我们希望抽取为一个自动化的工具。根据我们的需求，自动的封装对象，可以智能的帮我们封装数据。

    反射...
    requset里面带了好多参数....,根据要封装的对象获取相应的参数进行封装
    beanutils有丰富的操作javaBean的方法
    导包：commons-beanutils.jar commons-logging.jar
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        String email = req.getParameter("email");
    
    由于request获取的数据都是String类型的，要封装成Bean的话，需要类型装换.
        w3m build/reports/tests/test/index.html
    注意：在build.gradle中加了jar包之后，gradle build之后，要unzip build/distributions/gradle_javaweb.zip!!!!不然tomcat找不到需要的class 

    javaBean的属性值的设置是按照getter setter方法定的
    属性真正的名字是get或set后面的字符串,而不是Student等类的privat String username等字段

-------------------------------------------------------------------------

第四阶段 使用el进行错误消息提示及表单回显
    以前都是使用jsp表达式
    el->获取数据方便。如果没有属性就是什么都没有，而不是在页面显示null。即不用做三元运算

--------------------------------------------------------------------------

第五阶段 图书馆后台管理的增删改查以及前端显示
    1.后端的图书管理功能
        1.显示层:页面
        2.控制层：Servlet
        3.业务逻辑层：Service
        4.持久化层:Dao
        5.模型层：Bean
        6.数据库对应的表

        6.创建图书相关的表。哪些字段?
            主键    自增
            书名    varchar
            作者    varchar
            价格    double(11,2)
            销量    int
            库存    int
            封面图片    只保存图书封面的图片路径，绝对路径,base标签。保存图片相对于当前项目的路径 <img src="">
        
        7.对应的javaBean
            book
            Integer id;
            String title;
            String author;
            double price;
            int sales;
            int stock;
            String imgPath;

        8.创建sql:
            create table bs_book(
                id int(11) primary key auto_increment,
                title varchar(100) not null,
                author varchar(100) not null,
                price double(11,2),
                sales int(11),
                stock int(11),
                img_path varchar(200)
            )


开发数据库层
    面向接口开发
    接口类：BookDao
    接口方法：
        List<Book> getAllBook()显示所有图书
        boolean addBook(Book book);增加图书
        boolean delBook(Book book);删除图书
        boolean updateBook(Book book);修改图书
        Book getBook(Book book);找一本图书

    BookDaoimpl
    BookDaoimpl extends BaseDao<Book> implements BookDao

    
业务逻辑层
    增删改查    面向接口编程
    BookService(接口interface)
        add(Book book)
        update(Book book)//修改图书
        delete(Book book)
        getOne(Book book)
        getAll()//获取所有图书

    2.Servlet,控制器Controller,用来控制页面转发(见servlet.png)
        1.用户点击图书管理，显示所有的图书
            http://127.0.0.1:8080/01Servlet/pages/manager/book_manager.jsp
            点击图书管理-->交给Servlet-->查出数据-->交给页面显示
            BookManagerServlet
                list()//处理显示图书列表的请求

        2.添加图书
            1.用户点击添加图书-->链接到图书添加页面(book_edit.jsp)
                                 用户在页面输入图书的详细信息，点击提交
                                            |
                                           \|/
                                  BookManagerServlet
                                  add()添加图书，添加成功后还是显示图书列表
                                  重新请求列表显示方法list()
                   
        3.删除图书
            用户点击删除-->Servlet接受请求-->按照图书id删除图书-->还是回到图书列表页面

        4.修改图书
            1.用户点击修改，先要去Servlet,查出要修改的图书详情，显示到页面
            问题：修改和添加都是一个页面，都指向同一个方法。点击提交，现在是添加
                解决方法1：
                    去编辑页面的时候带上参数m=update,m=add来区分,在编辑页面取出参数即可
                解决方法2:
                    同样都是在编辑页面点击提交
                    method=add
                    将提交过来的数据封装
                    判断是否有id值，如果有id-->是update修改操作
                                    如果无id-->是add添加操作


问题存在：
    现在所有的图书都在列表里面.
        1.一次性查出所有的图书，页面乱
        2.加重了数据库负担
     
     解决：
     分页显示.
        一次取出部分数据。
     分页的原理：limit
        select * from bs_book limit 起始的索引，要取出的记录个数

     在管理员图书列表页面，显示分页数据
     显示层
        Servlet控制层。BookManagerServlet-->list
        Service层。查出部分图书(分页要求的。1,2)
        Dao层。 查出部分图书(分页查询 limit index,size)
        Bean层。 图书。需要一个分页模型(封装当前分页信息，当前第几页，总页数..)

     分页模型Page(请看分页模型.png)   select * from bs_book limit index,pageSize
        当前是第几页    int pageNo;
        总页码          int totalPage;
        总记录数        int totalCount;
        每页显示多少条记录  int pageSize;
        数据库查询的索引 int index;

     分页模型：
        1.创建Bean层的分页模型
        2.dao层,应该返回原始数据
            List<Book> getPageList(int index,int size);
            获取总记录数的方法 int getTotalCount();
        3.service层

        4.Servlet层
            第一请求显示图书列表，应该只显示第一页数据
            list()
            page()

        5.优化。每次只连续显示五页，而不是全部
            当前1   【1】 2 3 4 5
            当前2   1 【2】 3 4 5
            当前3   1 2 【3】 4 5
            当前4   2 3 【4】 5 6
            当前5   3 4 【5】 6 7
            ...

            相当于把当前页码的前两页和当前页的后两页显示出来
            分析情况来确定begin-end值
            1.总页码五页以内，全部显示 begin=1  end=totalPage

            2.总页码五页以上
                当前页码小于3时   显示1-5

                当前页码如果接近尾页    显示5页，显示后五页。总页码-4   10
                    6 7 【8】 9 10
                    6 7 8 【9】 10
                    6 7 8 9 【10】

        6.问题：
            每次进行修改或删除操作后都会回到第一夜

            我们应该让它停留在修改或删除时的那一夜

        7.分页抽取

        8.带条件的查询
            价格：xx元-xx元 查询

            点击查询-->通过Servlet处理-->按照要求查询并返回页面显示

            显示层
            控制器BookClientServlet-->page,只是简单的分页方法.基于原分页之上，带条件查询
            service bookservice-->getPage();带上查询条件查询
            dao-->编写一个条件查询的方法(价格区间)
            bean
                    


------------------------------------------------------------------------------

第六阶段 登录、登出(注销)、验证码、购物车
    1.登录
        怎么实现？
        将登录用户保存到session中，方便在其它资源共享
    在页面直接从session取出用户的详细信息
        问题：
            重启服务器后发现用户名显示不了了
            答：因为没有实现序列化接口

    2.登出
        用户退出系统
        直接将session设为不可用
    
    模型：
        dao;
        service;
        servlet;在servlet将session清空即可
        logout()

    3.根据session中是否有user对象就可以知道用户是否已经登录


购物车
    购物车：
        暂存物品信息

        实现：
            1.基于cookie,把购买的物品，都保存成cookie存在浏览器里
                cookie->都会携带。大量的数据被携带
            2.基于session,把购买的物品，保存到session中(服务器)。浏览器关闭丢失购物车
            3.基于数据库，把购买的物品保存到数据库中。

        模型层：
            方法
                void addBook2Cart(Book book);//在页面直接传入图书id
                void deleteItem(String bookid);//删除一个购物车
                List<CarItem> getItems();//获取所有的购物项，把这个交给页面
                void updateCount(String bookid, int count);//修改某一项的数据，传入修改后的数量
                void clear();//清空购物车
        
        Service:不用写
        
        Dao:不用写

        double,float在进行运算的时候会产生精度问题
        
        控制器：
            添加图书到购物车:
                用户在页面点击添加购物车，将图书id提交过去。在购物车中保存相应的条目
