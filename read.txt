read.txt

:Author: kalipy
:Email: kalipy@debian
:Date: 2020-11-30 20:24

1.服务器发给浏览器要保存的数据。浏览器保存相关数据
Http是无状态协议：
    无状态：服务器无法分辨每次请求来自谁
    如果客户端来的时候带上类似会员卡的东西，记录有卡号。

    Cookie:在浏览器端缓存数据的一种技术
    服务器发给浏览器的"会员卡"
    服务器让浏览器去保存一份数据，以后访问的时候带上相应的数据
    服务器发给浏览器


    1.cookie创建发送给浏览器：响应头多了：Set-Cookie:username=acher
        就是命令浏览器保存一个cookie:username=acher
        浏览器就保存这个字段，默认在一个会话期间只要访问这个项目,cookie都在

        以后只要是请求当前项目下的资源都会携带

    2.获取：
        Cookie[] cookies = req.getCookies();

    3.删除：
       1.默认cookie是在会话期间有效(浏览器一直不关)
       2.cookie可以修改默认的存活时间
            cookie.setMaxAge(0);
         Set-Cookie:username=acher; Expires=Thu, 01-Jan-1970 00:00:00

    4.持久化Cookie
        cookie.setMaxAge(60*60) 表示一小时后cookie才会被删除(浏览器自己会删除)

    5.设置cookie路径：告诉浏览器访问哪些资源会携带我这个cookie.
        默认：访问当前项目下的任何东西都会带上cookie

    6.修改cookie
        浏览器如何识别同一个cookie 根据cookie的name

Session:
    服务器端保存数据的技术:域对象(在整个会话期间保存的数据在任意资源都可以获取到)   
    作用：
        域对象共享数据

    1.可以在cookie中保存用户身份

    2.获取session

    session就是当前会话对象，他可以共享当前会话的数据
    服务器会给每个会话(重新启动，切换浏览器)创建独立的session。只为每个会话创建一个session,第一次获取的就是新创建的，以后用户都是之前创建的

Session创建流程01：
                    浏览器1                 浏览器2                     浏览器3
                     |                      |                            |
    第一次使用session|     第一次使用session|           第一次使用session|
                     |                      |                            |
                     |                      |                            |
                    \|/                    \|/                          \|/
    服务器:
            创建一个session:            创建一个session:         创建一个session:
            id:xx01                     id:xx02                     id:xx03


Session创建流程02：
                    浏览器1----------------------------------------------
                   4.jsessionid=xx01                                    |
                     |     命令浏览器保存session的id                    |
                     |      ^                                   Request Headers:
  1.第一次使用session|      |                           Cookie:JSESSIONID=xx01
                     |      |                                           |
                     |     Response Headers:                            |
                     |     3.Set-Cookie:JSESSIONID=xx01                 |
                     |      |                                 5.获取user|
                     |      |                                           | 
                     |      |                                           |
                    \|/     |                                           |
    服务器:                                                             |
            2.创建一个session:                                         \|/
            id:xx01              <--------------------------------------                                                     6.服务器是通过请求头中的jsessionid来                                               找到对应的session。

session:
    作用
        域对象共享数据

    1.可以在cookie中保存用户身份
        获取session
    2.session保存数据共享数据
    3.生命周期
        创建：第一次用session会创建一个新的session
            1.第一次获取
                html(使用servletrequest)
                .jsp(已经内置了session获取好了，请看jsp编译后的.class)
                    刚才之所以禁止cookie后获取不到数据，是因为禁止cookie后每次浏览器都不会带上jsesseionid，而去其它页面获取数据的链接是另一个jsp文件，当浏览器访问它时，jsp对应的.class又会内置获取好session，但是由于cookie被禁止，服务器会创建新的session,此时的jsessionid已经和上次不一样了，所以服务器找不到上次的数据了,况且禁止cookie后每次浏览器都不会带上jseesionid

        销毁：
            1.默认30分钟后session销毁
            2.手动设置session多少秒后过期session.setMaxInactiveInterval(3);
            3使session立即失效session.invalidate();

            1)新的会话获取的session是新的，和cookie的生命周期有关系。浏览器打开关闭开启新的会话并不会导致之前的session销毁。只是找不到之前的session了
            2)session在服务器有很多的垃圾..

    4.cookie被禁止
        导致会话控制会失效
        解决：
            使用url重写
                当cookie被禁止，可以使用url重写(把要访问的地址动态的加上jsessionid)

    5.session的活化与钝化
        现象：服务器关闭重新启动，只要浏览器没关，还是可以获取到session里面的内容
        钝化：服务器关闭以后，会将session序列化保存到硬盘里。可以在work/当前项目下观察SESSION.ser
        活化：服务器再次启动，会把之前序列化好的文件加载进来。就会再次加载之前保存的session,SESSION.ser包含了session域中的所有内容

        session域中的对象要能同session一起钝化到磁盘中，必须实现序列化接口，否则钝化不了，比如在jsp中new User(),而User类没有implements Serializable的话
